<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Multi-core Hash Joins: Radix Join Implementation Variants</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Multi-core Hash Joins
   </div>
   <div id="projectbrief">Main-memory hash join implementations for multi-core CPUs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Radix Join Implementation Variants</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__SoftwareManagedBuffer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SoftwareManagedBuffer.html">Optimized Partitioning Using SW-buffers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga346f6fe2a4f6f627c8366cbb50855de3"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Radix.html#ga346f6fe2a4f6f627c8366cbb50855de3">bucket_chaining_join</a> (const <a class="el" href="structrelation__t.html">relation_t</a> *const R, const <a class="el" href="structrelation__t.html">relation_t</a> *const S, <a class="el" href="structrelation__t.html">relation_t</a> *const tmpR, void *output)</td></tr>
<tr class="separator:ga346f6fe2a4f6f627c8366cbb50855de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d328ff191f35bc455febe7488650342"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Radix.html#ga0d328ff191f35bc455febe7488650342">get_hist_size</a> (uint32_t relSize) __attribute__((always_inline))</td></tr>
<tr class="separator:ga0d328ff191f35bc455febe7488650342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga015f9dc4ec1c7aff653d50f9640cf0c4"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Radix.html#ga015f9dc4ec1c7aff653d50f9640cf0c4">histogram_join</a> (const <a class="el" href="structrelation__t.html">relation_t</a> *const R, const <a class="el" href="structrelation__t.html">relation_t</a> *const S, <a class="el" href="structrelation__t.html">relation_t</a> *const tmpR, void *output)</td></tr>
<tr class="separator:ga015f9dc4ec1c7aff653d50f9640cf0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5e4c32c898c63e5e6ca3535820d9757"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Radix.html#gaa5e4c32c898c63e5e6ca3535820d9757">prefetch</a> (void *addr) __attribute__((always_inline))</td></tr>
<tr class="separator:gaa5e4c32c898c63e5e6ca3535820d9757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8993fd0618321b467f9b8d4ec9e99342"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Radix.html#ga8993fd0618321b467f9b8d4ec9e99342">histogram_optimized_join</a> (const <a class="el" href="structrelation__t.html">relation_t</a> *const R, const <a class="el" href="structrelation__t.html">relation_t</a> *const S, <a class="el" href="structrelation__t.html">relation_t</a> *const tmpR, void *output)</td></tr>
<tr class="separator:ga8993fd0618321b467f9b8d4ec9e99342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a84b94a95b3ab7e7e37087f95853e7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Radix.html#ga8a84b94a95b3ab7e7e37087f95853e7b">radix_cluster</a> (<a class="el" href="structrelation__t.html">relation_t</a> *restrict outRel, <a class="el" href="structrelation__t.html">relation_t</a> *restrict inRel, int32_t *restrict hist, int R, int D)</td></tr>
<tr class="separator:ga8a84b94a95b3ab7e7e37087f95853e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4acbb0fb32b0f32e0cb294539f82cbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Radix.html#gab4acbb0fb32b0f32e0cb294539f82cbb">radix_cluster_nopadding</a> (<a class="el" href="structrelation__t.html">relation_t</a> *outRel, <a class="el" href="structrelation__t.html">relation_t</a> *inRel, int R, int D)</td></tr>
<tr class="separator:gab4acbb0fb32b0f32e0cb294539f82cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c6b453afb151005db9d8c7c0e99e02e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Radix.html#ga0c6b453afb151005db9d8c7c0e99e02e">serial_radix_partition</a> (<a class="el" href="structtask__t.html">task_t</a> *const task, <a class="el" href="structtask__queue__t.html">task_queue_t</a> *join_queue, const int R, const int D)</td></tr>
<tr class="separator:ga0c6b453afb151005db9d8c7c0e99e02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0438af7afb57b3286f13b62830959716"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Radix.html#ga0438af7afb57b3286f13b62830959716">parallel_radix_partition</a> (<a class="el" href="structpart__t.html">part_t</a> *const part)</td></tr>
<tr class="separator:ga0438af7afb57b3286f13b62830959716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7040e50fa81cc98c382edafae7f593d4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Radix.html#ga7040e50fa81cc98c382edafae7f593d4">prj_thread</a> (void *param)</td></tr>
<tr class="separator:ga7040e50fa81cc98c382edafae7f593d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c5e45251d3e0c7b179731a4e5ae7e76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structresult__t.html">result_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Radix.html#ga1c5e45251d3e0c7b179731a4e5ae7e76">join_init_run</a> (<a class="el" href="structrelation__t.html">relation_t</a> *relR, <a class="el" href="structrelation__t.html">relation_t</a> *relS, JoinFunction jf, int nthreads)</td></tr>
<tr class="separator:ga1c5e45251d3e0c7b179731a4e5ae7e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47a11196a02364dc5df7b6c83a06cfe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structresult__t.html">result_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Radix.html#ga47a11196a02364dc5df7b6c83a06cfe2">PRO</a> (<a class="el" href="structrelation__t.html">relation_t</a> *relR, <a class="el" href="structrelation__t.html">relation_t</a> *relS, int nthreads)</td></tr>
<tr class="separator:ga47a11196a02364dc5df7b6c83a06cfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga017fe5959d6222c47b060621932aa90f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structresult__t.html">result_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Radix.html#ga017fe5959d6222c47b060621932aa90f">PRH</a> (<a class="el" href="structrelation__t.html">relation_t</a> *relR, <a class="el" href="structrelation__t.html">relation_t</a> *relS, int nthreads)</td></tr>
<tr class="separator:ga017fe5959d6222c47b060621932aa90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7c1673da91460a429fb7d131ca54ccc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structresult__t.html">result_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Radix.html#gab7c1673da91460a429fb7d131ca54ccc">PRHO</a> (<a class="el" href="structrelation__t.html">relation_t</a> *relR, <a class="el" href="structrelation__t.html">relation_t</a> *relS, int nthreads)</td></tr>
<tr class="separator:gab7c1673da91460a429fb7d131ca54ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84d79ef98c3b9aaf4b4d11f856a7a8b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structresult__t.html">result_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Radix.html#ga84d79ef98c3b9aaf4b4d11f856a7a8b6">RJ</a> (<a class="el" href="structrelation__t.html">relation_t</a> *relR, <a class="el" href="structrelation__t.html">relation_t</a> *relS, int nthreads)</td></tr>
<tr class="separator:ga84d79ef98c3b9aaf4b4d11f856a7a8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga346f6fe2a4f6f627c8366cbb50855de3" name="ga346f6fe2a4f6f627c8366cbb50855de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga346f6fe2a4f6f627c8366cbb50855de3">&#9670;&nbsp;</a></span>bucket_chaining_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t bucket_chaining_join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrelation__t.html">relation_t</a> *const&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrelation__t.html">relation_t</a> *const&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrelation__t.html">relation_t</a> *const&#160;</td>
          <td class="paramname"><em>tmpR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This algorithm builds the hashtable using the bucket chaining idea and used in PRO implementation. Join between given two relations is evaluated using the "bucket chaining" algorithm proposed by Manegold et al. It is used after the partitioning phase, which is common for all algorithms. Moreover, R and S typically fit into L2 or at least R and |R|*sizeof(int) fits into L2 cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>input relation R </td></tr>
    <tr><td class="paramname">S</td><td>input relation S </td></tr>
    <tr><td class="paramname">output</td><td>join results, if JOIN_RESULT_MATERIALIZE defined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of result tuples </dd></dl>

<p class="definition">Definition at line <a class="el" href="parallel__radix__join_8c_source.html#l00243">243</a> of file <a class="el" href="parallel__radix__join_8c_source.html">parallel_radix_join.c</a>.</p>

</div>
</div>
<a id="ga0d328ff191f35bc455febe7488650342" name="ga0d328ff191f35bc455febe7488650342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d328ff191f35bc455febe7488650342">&#9670;&nbsp;</a></span>get_hist_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_hist_size </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>relSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >computes and returns the histogram size for join </p>

<p class="definition">Definition at line <a class="el" href="parallel__radix__join_8c_source.html#l00316">316</a> of file <a class="el" href="parallel__radix__join_8c_source.html">parallel_radix_join.c</a>.</p>

</div>
</div>
<a id="ga015f9dc4ec1c7aff653d50f9640cf0c4" name="ga015f9dc4ec1c7aff653d50f9640cf0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga015f9dc4ec1c7aff653d50f9640cf0c4">&#9670;&nbsp;</a></span>histogram_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t histogram_join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrelation__t.html">relation_t</a> *const&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrelation__t.html">relation_t</a> *const&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrelation__t.html">relation_t</a> *const&#160;</td>
          <td class="paramname"><em>tmpR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Histogram-based hash table build method together with relation re-ordering as described by Kim et al. It joins partitions Ri, Si of relations R &amp; S. This is version is not optimized with SIMD and prefetching. The parallel radix join implementation using this function is PRH. </p>

<p class="definition">Definition at line <a class="el" href="parallel__radix__join_8c_source.html#l00331">331</a> of file <a class="el" href="parallel__radix__join_8c_source.html">parallel_radix_join.c</a>.</p>

</div>
</div>
<a id="ga8993fd0618321b467f9b8d4ec9e99342" name="ga8993fd0618321b467f9b8d4ec9e99342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8993fd0618321b467f9b8d4ec9e99342">&#9670;&nbsp;</a></span>histogram_optimized_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t histogram_optimized_join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrelation__t.html">relation_t</a> *const&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrelation__t.html">relation_t</a> *const&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrelation__t.html">relation_t</a> *const&#160;</td>
          <td class="paramname"><em>tmpR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Histogram-based hash table build method together with relation re-ordering as described by Kim et al. It joins partitions Ri, Si of relations R &amp; S. This is version includes SIMD and prefetching optimizations as described by Kim et al. The parallel radix join implementation using this function is PRHO. Note: works only for 32-bit keys. </p>

<p class="definition">Definition at line <a class="el" href="parallel__radix__join_8c_source.html#l00419">419</a> of file <a class="el" href="parallel__radix__join_8c_source.html">parallel_radix_join.c</a>.</p>

</div>
</div>
<a id="ga1c5e45251d3e0c7b179731a4e5ae7e76" name="ga1c5e45251d3e0c7b179731a4e5ae7e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c5e45251d3e0c7b179731a4e5ae7e76">&#9670;&nbsp;</a></span>join_init_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structresult__t.html">result_t</a> * join_init_run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrelation__t.html">relation_t</a> *&#160;</td>
          <td class="paramname"><em>relR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrelation__t.html">relation_t</a> *&#160;</td>
          <td class="paramname"><em>relS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JoinFunction&#160;</td>
          <td class="paramname"><em>jf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nthreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The template function for different joins: Basically each parallel radix join has a initialization step, partitioning step and build-probe steps. All our parallel radix implementations have exactly the same initialization and partitioning steps. Difference is only in the build-probe step. Here are all the parallel radix join implemetations and their Join (build-probe) functions:</p>
<ul>
<li>PRO, Parallel Radix Join Optimized --&gt; <a class="el" href="group__Radix.html#ga346f6fe2a4f6f627c8366cbb50855de3">bucket_chaining_join()</a></li>
<li>PRH, Parallel Radix Join Histogram-based --&gt; <a class="el" href="group__Radix.html#ga015f9dc4ec1c7aff653d50f9640cf0c4">histogram_join()</a></li>
<li>PRHO, Parallel Radix Histogram-based Optimized -&gt; <a class="el" href="group__Radix.html#ga8993fd0618321b467f9b8d4ec9e99342">histogram_optimized_join()</a> </li>
</ul>
<p >Not an elegant way of passing whether we will numa-localize, but this feature is experimental anyway.</p>

<p class="definition">Definition at line <a class="el" href="parallel__radix__join_8c_source.html#l01424">1424</a> of file <a class="el" href="parallel__radix__join_8c_source.html">parallel_radix_join.c</a>.</p>

</div>
</div>
<a id="ga0438af7afb57b3286f13b62830959716" name="ga0438af7afb57b3286f13b62830959716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0438af7afb57b3286f13b62830959716">&#9670;&nbsp;</a></span>parallel_radix_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parallel_radix_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpart__t.html">part_t</a> *const&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function implements the parallel radix partitioning of a given input relation. Parallel partitioning is done by histogram-based relation re-ordering as described by Kim et al. Parallel partitioning method is commonly used by all parallel radix join algorithms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>description of the relation to be partitioned </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parallel__radix__join_8c_source.html#l00715">715</a> of file <a class="el" href="parallel__radix__join_8c_source.html">parallel_radix_join.c</a>.</p>

</div>
</div>
<a id="gaa5e4c32c898c63e5e6ca3535820d9757" name="gaa5e4c32c898c63e5e6ca3535820d9757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5e4c32c898c63e5e6ca3535820d9757">&#9670;&nbsp;</a></span>prefetch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void prefetch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >software prefetching function </p>

<p class="definition">Definition at line <a class="el" href="parallel__radix__join_8c_source.html#l00403">403</a> of file <a class="el" href="parallel__radix__join_8c_source.html">parallel_radix_join.c</a>.</p>

</div>
</div>
<a id="ga017fe5959d6222c47b060621932aa90f" name="ga017fe5959d6222c47b060621932aa90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga017fe5959d6222c47b060621932aa90f">&#9670;&nbsp;</a></span>PRH()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structresult__t.html">result_t</a> * PRH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrelation__t.html">relation_t</a> *&#160;</td>
          <td class="paramname"><em>relR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrelation__t.html">relation_t</a> *&#160;</td>
          <td class="paramname"><em>relS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nthreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p >PRH: Parallel Radix Join Histogram-based.</p>
<p >The "Parallel Radix Join Histogram-based" implementation denoted as PRH implements the parallel radix join idea by Kim et al. without SIMD and prefetching optimizations. The difference from PRO is that the build phase is based on the histogram-based relation re-ordering idea.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relR</td><td>input relation R - inner relation </td></tr>
    <tr><td class="paramname">relS</td><td>input relation S - inner relation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of result tuples</dd></dl>

<p class="definition">Definition at line <a class="el" href="parallel__radix__join_8c_source.html#l01620">1620</a> of file <a class="el" href="parallel__radix__join_8c_source.html">parallel_radix_join.c</a>.</p>

</div>
</div>
<a id="gab7c1673da91460a429fb7d131ca54ccc" name="gab7c1673da91460a429fb7d131ca54ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7c1673da91460a429fb7d131ca54ccc">&#9670;&nbsp;</a></span>PRHO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structresult__t.html">result_t</a> * PRHO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrelation__t.html">relation_t</a> *&#160;</td>
          <td class="paramname"><em>relR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrelation__t.html">relation_t</a> *&#160;</td>
          <td class="paramname"><em>relS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nthreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p >PRHO: Parallel Radix Join Histogram-based Optimized.</p>
<p >The "Parallel Radix Join Histogram-based Optimized" implementation denoted as PRHO implements the parallel radix join idea by Kim et al. with SIMD and prefetching optimizations. The difference from PRH is that the probe phase uses SIMD and software prefetching optimizations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relR</td><td>input relation R - inner relation </td></tr>
    <tr><td class="paramname">relS</td><td>input relation S - inner relation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of result tuples</dd></dl>

<p class="definition">Definition at line <a class="el" href="parallel__radix__join_8c_source.html#l01627">1627</a> of file <a class="el" href="parallel__radix__join_8c_source.html">parallel_radix_join.c</a>.</p>

</div>
</div>
<a id="ga7040e50fa81cc98c382edafae7f593d4" name="ga7040e50fa81cc98c382edafae7f593d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7040e50fa81cc98c382edafae7f593d4">&#9670;&nbsp;</a></span>prj_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * prj_thread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The main thread of parallel radix join. It does partitioning in parallel with other threads and during the join phase, picks up join tasks from the task queue and calls appropriate JoinFunction to compute the join task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="parallel__radix__join_8c_source.html#l00964">964</a> of file <a class="el" href="parallel__radix__join_8c_source.html">parallel_radix_join.c</a>.</p>

</div>
</div>
<a id="ga47a11196a02364dc5df7b6c83a06cfe2" name="ga47a11196a02364dc5df7b6c83a06cfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47a11196a02364dc5df7b6c83a06cfe2">&#9670;&nbsp;</a></span>PRO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structresult__t.html">result_t</a> * PRO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrelation__t.html">relation_t</a> *&#160;</td>
          <td class="paramname"><em>relR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrelation__t.html">relation_t</a> *&#160;</td>
          <td class="paramname"><em>relS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nthreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p >PRO: Parallel Radix Join Optimized.</p>
<p >The "Parallel Radix Join Optimized" implementation denoted as PRO implements the parallel radix join idea by Kim et al. with further optimizations. Mainly it uses the bucket chaining for the build phase instead of the histogram-based relation re-ordering and performs better than other variations such as PRHO, which applies SIMD and prefetching optimizations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relR</td><td>input relation R - inner relation </td></tr>
    <tr><td class="paramname">relS</td><td>input relation S - inner relation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of result tuples</dd></dl>

<p class="definition">Definition at line <a class="el" href="parallel__radix__join_8c_source.html#l01613">1613</a> of file <a class="el" href="parallel__radix__join_8c_source.html">parallel_radix_join.c</a>.</p>

</div>
</div>
<a id="ga8a84b94a95b3ab7e7e37087f95853e7b" name="ga8a84b94a95b3ab7e7e37087f95853e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a84b94a95b3ab7e7e37087f95853e7b">&#9670;&nbsp;</a></span>radix_cluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void radix_cluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrelation__t.html">relation_t</a> *restrict&#160;</td>
          <td class="paramname"><em>outRel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrelation__t.html">relation_t</a> *restrict&#160;</td>
          <td class="paramname"><em>inRel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *restrict&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Radix clustering algorithm (originally described by Manegold et al) The algorithm mimics the 2-pass radix clustering algorithm from Kim et al. The difference is that it does not compute prefix-sum, instead the sum (offset in the code) is computed iteratively.</p>
<dl class="section warning"><dt>Warning</dt><dd>This method puts padding between clusters, see radix_cluster_nopadding for the one without padding.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outRel</td><td>[out] result of the partitioning </td></tr>
    <tr><td class="paramname">inRel</td><td>[in] input relation </td></tr>
    <tr><td class="paramname">hist</td><td>[out] number of tuples in each partition </td></tr>
    <tr><td class="paramname">R</td><td>cluster bits </td></tr>
    <tr><td class="paramname">D</td><td>radix bits per pass </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuples per partition. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parallel__radix__join_8c_source.html#l00545">545</a> of file <a class="el" href="parallel__radix__join_8c_source.html">parallel_radix_join.c</a>.</p>

</div>
</div>
<a id="gab4acbb0fb32b0f32e0cb294539f82cbb" name="gab4acbb0fb32b0f32e0cb294539f82cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4acbb0fb32b0f32e0cb294539f82cbb">&#9670;&nbsp;</a></span>radix_cluster_nopadding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void radix_cluster_nopadding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrelation__t.html">relation_t</a> *&#160;</td>
          <td class="paramname"><em>outRel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrelation__t.html">relation_t</a> *&#160;</td>
          <td class="paramname"><em>inRel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Radix clustering algorithm which does not put padding in between clusters. This is used only by single threaded radix join implementation RJ.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outRel</td><td></td></tr>
    <tr><td class="paramname">inRel</td><td></td></tr>
    <tr><td class="paramname">hist</td><td></td></tr>
    <tr><td class="paramname">R</td><td></td></tr>
    <tr><td class="paramname">D</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parallel__radix__join_8c_source.html#l00595">595</a> of file <a class="el" href="parallel__radix__join_8c_source.html">parallel_radix_join.c</a>.</p>

</div>
</div>
<a id="ga84d79ef98c3b9aaf4b4d11f856a7a8b6" name="ga84d79ef98c3b9aaf4b4d11f856a7a8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84d79ef98c3b9aaf4b4d11f856a7a8b6">&#9670;&nbsp;</a></span>RJ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structresult__t.html">result_t</a> * RJ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrelation__t.html">relation_t</a> *&#160;</td>
          <td class="paramname"><em>relR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrelation__t.html">relation_t</a> *&#160;</td>
          <td class="paramname"><em>relS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nthreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p >RJ: Radix Join.</p>
<p >The "Radix Join" implementation denoted as RJ implements the single-threaded original multipass radix cluster join idea by Manegold et al.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relR</td><td>input relation R - inner relation </td></tr>
    <tr><td class="paramname">relS</td><td>input relation S - inner relation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>nthreads parameter does not have any effect for this algorithm. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>number of result tuples</dd></dl>

<p class="definition">Definition at line <a class="el" href="parallel__radix__join_8c_source.html#l01634">1634</a> of file <a class="el" href="parallel__radix__join_8c_source.html">parallel_radix_join.c</a>.</p>

</div>
</div>
<a id="ga0c6b453afb151005db9d8c7c0e99e02e" name="ga0c6b453afb151005db9d8c7c0e99e02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c6b453afb151005db9d8c7c0e99e02e">&#9670;&nbsp;</a></span>serial_radix_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serial_radix_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtask__t.html">task_t</a> *const&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtask__queue__t.html">task_queue_t</a> *&#160;</td>
          <td class="paramname"><em>join_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function implements the radix clustering of a given input relations. The relations to be clustered are defined in <a class="el" href="structtask__t.html">task_t</a> and after clustering, each partition pair is added to the join_queue to be joined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>description of the relation to be partitioned </td></tr>
    <tr><td class="paramname">join_queue</td><td>task queue to add join tasks after clustering </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parallel__radix__join_8c_source.html#l00658">658</a> of file <a class="el" href="parallel__radix__join_8c_source.html">parallel_radix_join.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Sep 20 2022 05:28:03 for Multi-core Hash Joins by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
