<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Multi-core Hash Joins: Main-Memory Hash Joins On Multi-Core CPUs: Tuning to the Underlying Hardware</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Multi-core Hash Joins
   </div>
   <div id="projectbrief">Main-memory hash join implementations for multi-core CPUs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Main-Memory Hash Joins On Multi-Core CPUs: Tuning to the Underlying Hardware </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p >This package provides implementations of the main-memory hash join algorithms described and studied in our ICDE 2013 paper. Namely, the implemented algorithms are the following with the abbreviated names:</p>
<ul>
<li>NPO: No Partitioning Join Optimized (Hardware-oblivious algo. in paper)</li>
<li>PRO: Parallel Radix Join Optimized (Hardware-conscious algo. in paper)</li>
<li>PRH: Parallel Radix Join Histogram-based</li>
<li>PRHO: Parallel Radix Join Histogram-based Optimized</li>
<li>RJ: Radix Join (single-threaded)</li>
<li>NPO_st: No Partitioning Join Optimized (single-threaded)</li>
</ul>
<h1><a class="anchor" id="compilation"></a>
Compilation</h1>
<p >The package includes implementations of the algorithms and also the driver code to run and repeat the experimental studies described in the paper.</p>
<p >The code has been written using standard GNU tools and uses autotools for configuration. Thus, compilation should be as simple as:</p>
<pre class="fragment">       $ ./configure
       $ make
</pre><p >Besides the usual ./configure options, compilation can be customized with the following options: </p><pre class="fragment">   --enable-debug         enable debug messages on commandline  [default=no]
   --enable-key8B         use 8B keys and values making tuples 16B  [default=no]
   --enable-perfcounters  enable performance monitoring with Intel PCM  [no]
   --enable-paddedbucket  enable padding of buckets to cache line size in NPO [no]
   --enable-timing        enable execution timing  [default=yes]
   --enable-syncstats     enable synchronization timing stats  [default=no]
   --enable-skewhandling  enable fine-granular task decomposition based skew handling in radix [default=no]
</pre><p> Additionally, the code can be configured to enable further optimizations discussed in the Technical Report version of the paper: </p><pre class="fragment">   --enable-prefetch-npj   enable prefetching in no partitioning join [default=no]
   --enable-swwc-part      enable software write-combining optimization in
                           partitioning (Experimental, not tested extensively) ? [default=no]
</pre><p> Our code makes use of the Intel Performance Counter Monitor tool which was slightly modified to be integrated in to our implementation. The original code can be downloaded from:</p>
<p ><a href="http://software.intel.com/en-us/articles/intel-performance-counter-monitor/">http://software.intel.com/en-us/articles/intel-performance-counter-monitor/</a></p>
<p >We are providing the copy that we used for our experimental study under <b><code>lib/intel-pcm-1.7</code></b> directory which comes with its own Makefile. Its build process is actually separate from the autotools build process but with the <code>&ndash;enable-perfcounters</code> option, make command from the top level directory also builds the shared library <b>&lsquo;libperf.so&rsquo;</b> that we link to our code. After compiling with &ndash;enable-perfcounters, in order to run the executable add &lsquo;lib/intel-pcm-1.7/lib&rsquo; to your <code>LD_LIBRARY_PATH</code>. In addition, the code must be run with root privileges to acces model specific registers, probably after issuing the following command: <code>modprobe msr</code>. Also note that with &ndash;enable-perfcounters the code is compiled with g++ since Intel code is written in C++.</p>
<p >We have successfully compiled and run our code on different Linux variants; the experiments in the paper were performed on Debian and Ubuntu Linux systems.</p>
<h1><a class="anchor" id="usage"></a>
Usage and Invocation</h1>
<p >The <code>mchashjoins</code> binary understands the following command line options: </p><pre class="fragment">      Join algorithm selection, algorithms : RJ, PRO, PRH, PRHO, NPO, NPO_st
         -a --algo=&lt;name&gt;    Run the hash join algorithm named &lt;name&gt; [PRO]
 
      Other join configuration options, with default values in [] :
         -n --nthreads=&lt;N&gt;  Number of threads to use &lt;N&gt; [2]
         -r --r-size=&lt;R&gt;    Number of tuples in build relation R &lt;R&gt; [128000000]
         -s --s-size=&lt;S&gt;    Number of tuples in probe relation S &lt;S&gt; [128000000]
         -x --r-seed=&lt;x&gt;    Seed value for generating relation R &lt;x&gt; [12345]    
         -y --s-seed=&lt;y&gt;    Seed value for generating relation S &lt;y&gt; [54321]    
         -z --skew=&lt;z&gt;      Zipf skew parameter for probe relation S &lt;z&gt; [0.0]  
         --non-unique       Use non-unique (duplicated) keys in input relations 
         --full-range       Spread keys in relns. in full 32-bit integer range
         --basic-numa       Numa-localize relations to threads (Experimental)

      Performance profiling options, when compiled with --enable-perfcounters.
         -p --perfconf=&lt;P&gt;  Intel PCM config file with upto 4 counters [none]  
         -o --perfout=&lt;O&gt;   Output file to print performance counters [stdout]
 
      Basic user options
          -h --help         Show this message
          --verbose         Be more verbose -- show misc extra info 
          --version         Show version</pre><p> The above command line options can be used to instantiate a certain configuration to run various joins and print out the resulting statistics. Following the same methodology of the related work, our joins never materialize their results as this would be a common cost for all joins. We only count the number of matching tuples and report this. In order to materialize results, one needs to copy results to a result buffer in the corresponding locations of the source code.</p>
<h1><a class="anchor" id="config"></a>
Configuration Parameters</h1>
<h2><a class="anchor" id="cpumapping"></a>
Logical to Pyhsical CPU Mapping</h2>
<p >If running on a machine with multiple CPU sockets and/or SMT feature enabled, then it is necessary to identify correct mappings of CPUs on which threads will execute. For instance one of our experiment machines, Intel Xeon L5520 had 2 sockets and each socket had 4 cores and 8 threads. In order to only utilize the first socket, we had to use the following configuration for mapping threads 1 to 8 to correct CPUs:</p>
<pre class="fragment">cpu-mapping.txt
8 0 1 2 3 8 9 10 11
</pre><p >This file is must be created in the executable directory and used by default if exists in the directory. It basically says that we will use 8 CPUs listed and threads spawned 1 to 8 will map to the given list in order. For instance thread 5 will run CPU 8. This file must be changed according to the system at hand. If it is absent, threads will be assigned round-robin. This CPU mapping utility is also integrated into the Wisconsin implementation (found in &lsquo;wisconsin-src&rsquo;) and same settings are also valid there.</p>
<h2><a class="anchor" id="perfmonitoring"></a>
Performance Monitoring</h2>
<p >For performance monitoring a config file can be provided on the command line with &ndash;perfconf which specifies which hardware counters to monitor. For detailed list of hardware counters consult to "Intel 64 and IA-32 
   Architectures Software Developerâ€™s Manual" Appendix A. For an example configuration file used in the experiments, see <b>&lsquo;pcm.cfg&rsquo;</b> file. Lastly, an output file name with &ndash;perfout on commandline can be specified to print out profiling results, otherwise it defaults to stdout.</p>
<h2><a class="anchor" id="systemparams"></a>
System and Implementation Parameters</h2>
<p >The join implementations need to know about the system at hand to a certain degree. For instance <a class="el" href="group__SystemParameters.html#gaf89f60b07247176687889ade776c8e10">CACHE_LINE_SIZE</a> is required by both of the implementations. In case of no partitioning join, other implementation parameters such as bucket size or whether to pre-allocate for overflowing buckets are parametrized and can be modified in &lsquo;<a class="el" href="npj__params_8h.html" title="Constant parameters used by No Partitioning Join implementations.">npj_params.h</a>&rsquo;.</p>
<p >On the other hand, radix joins are more sensitive to system parameters and the optimal setting of parameters should be found from machine to machine to get the same results as presented in the paper. System parameters needed are <a class="el" href="group__SystemParameters.html#gaf89f60b07247176687889ade776c8e10">CACHE_LINE_SIZE</a>, <a class="el" href="group__SystemParameters.html#gab928f78a446ecf9ef7023e3b664c8d21">L1_CACHE_SIZE</a> and <a class="el" href="group__SystemParameters.html#gaef02e51975cf8348fa68e75b11045cef">L1_ASSOCIATIVITY</a>. Other implementation parameters specific to radix join are also important such as <a class="el" href="prj__params_8h.html#a7ed7fa4bae22ce2dba82110bc2dd73b4">NUM_RADIX_BITS</a> which determines number of created partitions and <a class="el" href="prj__params_8h.html#a15743b15bea8ad6259b517806b9b7f21">NUM_PASSES</a> which determines number of partitioning passes. Our implementations support between 1 and 2 passes and they can be configured using these parameters to find the ideal performance on a given machine.</p>
<h1><a class="anchor" id="data"></a>
Generating Data Sets of Our Experiments</h1>
<p >Here we briefly describe how to generate data sets used in our experiments with the command line parameters above.</p>
<h2><a class="anchor" id="workloadB"></a>
Workload B</h2>
<p >In this data set, the inner relation R and outer relation S have 128*10^6 tuples each. The tuples are 8 bytes long, consisting of 4-byte (or 32-bit) integers and a 4-byte payload. As for the data distribution, if not explicitly specified, we use relations with randomly shuffled unique keys ranging from 1 to 128*10^6. To generate this data set, append the following parameters to the executable <code>mchashjoins</code>:</p>
<pre class="fragment">      $ ./mchashjoins [other options] --r-size=128000000 --s-size=128000000 
</pre><dl class="section note"><dt>Note</dt><dd>Configure must have run without &ndash;enable-key8B.</dd></dl>
<h2><a class="anchor" id="workloadA"></a>
Workload A</h2>
<p >This data set reflects the case where the join is performed between the primary key of the inner relation R and the foreign key of the outer relation S. The size of R is fixed at 16*2^20 and size of S is fixed at 256*2^20. The ratio of the inner relation to the outer relation is 1:16. In this data set, tuples are represented as (key, payload) pairs of 8 bytes each, summing up to 16 bytes per tuple. To generate this data set do the following:</p>
<pre class="fragment">     $ ./configure --enable-key8B
     $ make
     $ ./mchashjoins [other options] --r-size=16777216 --s-size=268435456 
</pre><h2><a class="anchor" id="skew"></a>
Introducing Skew in Data Sets</h2>
<p >Skew can be introduced to the relation S as in our experiments by appending the following parameter to the command line, which is basically a Zipf distribution skewness parameter:</p>
<pre class="fragment">     $ ./mchashjoins [other options] --skew=1.05
</pre><h1><a class="anchor" id="wisconsin"></a>
Wisconsin Implementation</h1>
<p >A slightly modified version of the original implementation provided by Blanas et al. from University of Wisconsin is provided under &lsquo;wisconsin-src&rsquo; directory. The changes we made are documented in the header of the README file. These implementations provide the algorithms mentioned as &lsquo;non-optimized no partitioning join&rsquo; and &lsquo;non-optimized radix join&rsquo; in our paper. The original source code can be downloaded from <a href="http://pages.cs.wisc.edu/âˆ¼sblanas/files/multijoin.tar.bz2">http://pages.cs.wisc.edu/âˆ¼sblanas/files/multijoin.tar.bz2</a> .</p>
<dl class="section author"><dt>Author</dt><dd>Cagri Balkesen <a href="#" onclick="location.href='mai'+'lto:'+'cag'+'ri'+'.ba'+'lk'+'ese'+'n@'+'inf'+'.e'+'thz'+'.c'+'h'; return false;">cagri<span class="obfuscator">.nosp@m.</span>.bal<span class="obfuscator">.nosp@m.</span>kesen<span class="obfuscator">.nosp@m.</span>@inf<span class="obfuscator">.nosp@m.</span>.ethz<span class="obfuscator">.nosp@m.</span>.ch</a></dd></dl>
<p>(c) 2012, ETH Zurich, Systems Group </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 4 2022 15:20:47 for Multi-core Hash Joins by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
